# JVM 类加载机制（JVM Classloading Mechanism）

Java 类`class`从被加载到 JVM 虚拟机至被卸载，整个生命周期包括几个阶段：

1. 加载 (Loading)
2. 验证 (Verification)
3. 准备 (Preparation)
4. 解析 (Resolution)
5. 初始化 (Initialization)
6. 使用 (Using)
7. 卸载 (Unloading)

![JVM-ClassloadingMechanism-1-ClassloadingFlow][JVM-ClassloadingMechanism-1-ClassloadingFlow]

> 图：Java 类加载流程

# 加载阶段

在加载阶段，JVM 完成以下三件事情：

- 通过一个类的**全限定名**获取类定义的**二进制字节流**，获取类字节流的途径可以是：Class 文件、Jar 包、网络、文件自动生成。

- 将类字节流的**静态存储结构**转化为方法区**运行时数据结构**。

- 在 JVM 堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区类数据的访问入口。

[JVM-ClassloadingMechanism-1-ClassloadingFlow]: ../../images/JVM-ClassloadingMechanism-1-ClassloadingFlow.png

# 验证阶段

验证是为了确保加载的`Class`字节流格式正确，符合 JVM 虚拟机的要求，且不会损害虚拟机安全。

大致有几个验证步骤：

- 文件格式验证：保证类字节流可以被正确地解析，并被存储到方法区中。

- 元数据验证：确保元数据信息符合 Java 语法规范。

- 字节码验证：对类的方法体进行校验，确保运行时不会危害到虚拟机。

- 符号引用验证：对类自身外的引用符号匹配进行校验 (如：常量池中的符号引用)。

# 准备阶段

准备阶段主要为类变量分配内存并设置变量初始值，分配在方法区中。

注意要点：

- 此时的内存分配只包括类变量`static`，实例变量会在对象初始化时分配在 JVM 堆中。

- 此时变量的初始值是其对应数据类型的默认零值（如：`0`、`null`、`false`等)。

举例说明：

```java
public static int number = 6;
```

类变量`number`在准备阶段后的值为`0`而不是`6`。因为此时还没有开始执行任何 Java 方法。而将变量`number`赋值为`6`是在程序编译后执行`putstatic`指令，存放于类的构造器`<clinit>()`方法中，所以`number`赋值为`6`的操作将在**初始化阶段**进行。

```java
public static final int number = 6;
```

但是，如果变量加上`final`关键字修饰，则在编译期间就为`number`生成 ConstantValue 属性将其结果放入常量池中，在准备阶段 JVM 虚拟机根据 ConstantValue 属性直接将`number`赋值为`6`，即：在准备阶段后`number`值为`6`。

# 解析阶段

在解析阶段，JVM 虚拟机完成将常量池中符号引用转化为直接引用的过程。

- 符号引用：以一组符号来描述所引用的目标。与虚拟机实现的内存布局无关，即：所引用的目标不一定加载到了内存中。

- 直接引用：一个指向目标的指针。与虚拟机实现的内存布局相关，如果目标有了直接引用，说明已经被加载到了内存中。

解析主要针对类或接口、字段、类方法、接口方法四类符号引用，他们和常量池中的类型对应关系如下表。

| 符号引用 | 常量类型（常量池） |
| ------- | --------------- |
| 类或接口 | `CONSTANT_Class_info` |
| 字段    | `CONSTANT_Fieldref_info` |
| 类方法  | `CONSTANT_Methodref_info` |
| 接口方法 | `CONSTANT_InterfaceMethodref_info` |

> 表：符号引用与常量类型对应关系表

# 初始化阶段

初始化阶段开始执行类中的 Java 代码，主要执行`<clinit>()`类构造器方法。

类构造器方法`<clinit>()`由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类 变量只能赋值，不能访问。

父类的`<clinit>()`方法先于子类执行，也就意味着父类中定义的静态语句块执行要优先于子类。

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作。因此接口与类一样都会生成`<clinit>()`方法。但 接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。只有当父接口中定义的变量需要在子接口使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。

**JVM 虚拟机保证一个类的`<clinit>()`方法在多线程环境下被正确的加锁和同步**。如果多个线程同时初始化一个类，只会有一个线程执行这个类的`<clinit>()`构造器方法，其它线程都会阻塞等待，直到活动线程执行`<clinit>()`构造器方法完毕。如果在一个类的`<clinit>()`方法中有比较耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞比较隐蔽。



<!-- EOF -->