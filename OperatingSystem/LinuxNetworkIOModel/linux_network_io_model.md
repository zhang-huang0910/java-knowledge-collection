# Linux 操作系统 I/O 模型

- 文件描述符（File Descripto）：在操作系统中，每个打开的文件通过唯一描述符进行引用。

## 阻塞 I/O 模型（Blocking I/O）

阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去；条件满足，则进行下一步操作。

应用程序通过系统调用`recvfrom`接收数据，如果操作系统内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，`recvfrom`完成数据报复制工作，应用进程才能结束阻塞状态。

应用进程在**等待数据**与**复制数据**两个阶段都会被阻塞，阻塞式 I/O 能够及时返回数据，无延迟；操作系统内核开发简单。但对于用户进程来说，性能差。

## 同步非阻塞 I/O 模型（Non-blocking I/O）

同步非阻塞 I/O 模型是指，应用进程与内核交互时，如果请求的数据未到达，不再一味的等着，而是直接返回。然后通过轮询（Polling）的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。

进程调用非阻塞`recvfrom`系统调用后，并没有被阻塞，内核马上返回到进程。如果数据尚未准备好，会返回一个`EWOULDBLOCK`标识，进程收到后就知道数据尚未准备好，可以选择处理其他事情，然后再次发起`recvfrom`系统调用，循环往复直到数据准备好，再拷贝数据到进程。需要注意的是，拷贝数据的过程，进程依然会阻塞。

同步非阻塞 I/O 相比于同步阻塞 I/O 来说，能够让进程在等待数据准备的时间执行其他任务，提高了时间利用率，缺点是任务完成的响应延迟增大，导致整体数据吞吐量降低。

## 信号驱动 I/O 模型（Signal-driven I/O）

信号驱动 I/O 模型是指，应用进程在请求 I/O 时通知内核，如果某个事件发生时，请向我发送一个信号。收到信号后，信号对应的处理函数会执行后续处理。

应用进程预先向内核注册一个信号处理函数，然后用户进程返回，不阻塞。当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。

开启套接字 Socket 信号驱动式 I/O 功能，并通过`sigaction`系统调用注册一个信号处理函数。该系统调用立即返回，用户进程继续工作，并没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个`SIGIO`信号，随后既可以在信号处理函数中调用`recvfrom`读取数据报并通知主循环数据已准备好待处理；也可以立即通知主循环，让它读取数据报。

信号驱动 I/O 模型的优势在于等待数据报到达期间进程不阻塞，只需要等待信号处理函数的通知，响应延迟降低。

### I/O 多路复用模型（I/O Multiplexing）

由于同步非阻塞 I/O 需要不断主动轮训，这会消耗大量 CPU 时间，导致运行效率与系统吞吐量的降低。

I/O 多路复用技术就是由内核来完成对多个任务的轮询工作，Linux 操作系统`select/poll/epoll`就是实现这一功能。

IO复用的轮询与非阻塞IO的轮询的区别是前者可以等待多个socket，实现对多个IO端口的监听，当其中任何一个socket的数据准备完成就能返回进行可读。select/poll/epoll也会使进程阻塞，但个阻塞IO不同的是，前者可以同时阻塞多个IO操作。与IO多路复用密切相关的另一种IO模型是多线程中使用阻塞式IO，这两种模型极为相似，但一个是进程使用select阻塞于多个文件描述符上，一个是使用多线程分别调用诸如recvfrom之类的阻塞式IO系统调用上。



<!-- EOF -->